{"version":3,"file":"vuex-module-maker.js","mappings":"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","sources":["webpack:///webpack/universalModuleDefinition","webpack:///./node_modules/detect-node/browser.js","webpack:///external umd {\"commonjs\":\"vuex-cache\",\"commonjs2\":\"vuex-cache\",\"amd\":\"vuex-cache\",\"root\":\"vuex-cache\"}","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/utils/jsHelpers.js","webpack:///./src/utils/messages.js","webpack:///./src/actionConfigs.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/util.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/native.js","webpack:///./node_modules/oblivious-set/dist/es/index.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/options.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js","webpack:///./node_modules/unload/dist/es/browser.js","webpack:///./node_modules/unload/dist/es/index.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/leader-election.js","webpack:///./src/channel.js","webpack:///./src/VuexModuleMaker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory((function webpackLoadOptionalExternalModule() { try { return require(\"vuex-cache\"); } catch(e) {} }()));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vuex-cache\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vuexModuleMaker\"] = factory((function webpackLoadOptionalExternalModule() { try { return require(\"vuex-cache\"); } catch(e) {} }()));\n\telse\n\t\troot[\"vuexModuleMaker\"] = factory(root[\"vuex-cache\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__113__) => {\nreturn ","module.exports = false;\n\n","if(typeof __WEBPACK_EXTERNAL_MODULE__113__ === 'undefined') { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__113__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export function getFieldFrom(fieldChain, obj) {\n  if (!fieldChain.length) return obj\n\n  if (Object.prototype.hasOwnProperty.call(obj, fieldChain[0])) {\n    return getFieldFrom(fieldChain.slice(1), obj[fieldChain[0]])\n  } else {\n    return null\n  }\n}\n\nexport function camelToUpSnake(string) {\n  return string\n    .replace(/([A-Z])/g, function (m) {\n      return \"_\" + m\n    })\n    .toUpperCase()\n}\n","export default {\n  prefix: '[Vuex-Module-Maker]:',\n  warnings: {\n    vuexCache: {\n      peerDependency:\n        'You must install vuex-cache to be able to use the cache.',\n    },\n  },\n}\n","export default {\n  common: {\n    list: {\n      hasMetadata: true,\n      append: true\n    },\n    create: {\n      appendAlways: true\n    },\n    edit: {\n      editing: true\n    }\n  }\n}\n","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport var PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVED_VOID = Promise.resolve();\nexport function sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      return res(resolveWith);\n    }, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */\n\nexport function randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nexport function microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n/**\n * copied from the 'detect-node' npm module\n * We cannot use the module directly because it causes problems with rollup\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\n\nexport var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';","import { microSeconds as micro, isNode, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (isNode && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.map = new Map();\n        /**\n         * Creating calls to setTimeout() is expensive,\n         * so we only do that if there is not timeout already open.\n         */\n        this._to = false;\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.map.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.map.set(value, now());\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(function () {\n                _this._to = false;\n                removeTooOldValues(_this);\n            }, 0);\n        }\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.map.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.map[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var next = iterator.next().value;\n        if (!next) {\n            return; // no more elements\n        }\n        var value = next[0];\n        var time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map","export function fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.\n\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods\n\n  if (originalOptions.methods) options.methods = originalOptions.methods; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  /**\n   * On linux use 'ulimit -Hn' to get the limit of open files.\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\n   */\n\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n * \n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\n\nexport var TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\n\nexport function commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n\n  var openRequest = IndexedDB.open(dbName);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise(function (res, rej) {\n    tx.oncomplete = function () {\n      return res();\n    };\n\n    tx.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nexport function getAllMessages(db) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n\n  if (objectStore.getAll) {\n    var getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise(function (res, rej) {\n      getAllRequest.onerror = function (err) {\n        return rej(err);\n      };\n\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res, rej) {\n    var openCursorRequest = openCursor();\n\n    openCursorRequest.onerror = function (err) {\n      return rej(err);\n    };\n\n    openCursorRequest.onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessagesById(db, ids) {\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(function (id) {\n    var deleteRequest = objectStore[\"delete\"](id);\n    return new Promise(function (res) {\n      deleteRequest.onsuccess = function () {\n        return res();\n      };\n    });\n  }));\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return removeMessagesById(db, tooOld.map(function (msg) {\n      return msg.id;\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nimport { sleep, randomToken, microSeconds as micro, isNode } from '../util.js';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = randomToken();\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n\n  return defaultTime;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import { microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return 5;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import NativeMethod from './methods/native.js';\nimport IndexeDbMethod from './methods/indexed-db.js';\nimport LocalstorageMethod from './methods/localstorage.js';\nimport SimulateMethod from './methods/simulate.js'; // the line below will be removed from es5/browser builds\n\n\nimport { isNode } from './util.js'; // order is important\n\nvar METHODS = [NativeMethod, // fastest\nIndexeDbMethod, LocalstorageMethod];\nexport function chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds\n\n\n\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n\n\n  if (!options.webWorkerSupport && !isNode) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error(\"No useable method found in \" + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}","import { isPromise, PROMISE_RESOLVED_FALSE, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\n\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return PROMISE_RESOLVED_FALSE;\n  }\n}\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","/* global WorkerGlobalScope */\nfunction add(fn) {\n  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {// this is run inside of a webworker\n  } else {\n    /**\n     * if we are on react-native, there is no window.addEventListener\n     * @link https://github.com/pubkey/unload/issues/6\n     */\n    if (typeof window.addEventListener !== 'function') return;\n    /**\n     * for normal browser-windows, we use the beforeunload-event\n     */\n\n    window.addEventListener('beforeunload', function () {\n      fn();\n    }, true);\n    /**\n     * for iframes, we have to use the unload-event\n     * @link https://stackoverflow.com/q/47533670/3443137\n     */\n\n    window.addEventListener('unload', function () {\n      fn();\n    }, true);\n  }\n  /**\n   * TODO add fallback for safari-mobile\n   * @link https://stackoverflow.com/a/26193516/3443137\n   */\n\n}\n\nexport default {\n  add: add\n};","import isNode from 'detect-node';\nimport BrowserMethod from './browser.js';\nimport NodeMethod from './node.js';\nvar USE_METHOD = isNode ? NodeMethod : BrowserMethod;\nvar LISTENERS = new Set();\nvar startedListening = false;\n\nfunction startListening() {\n  if (startedListening) return;\n  startedListening = true;\n  USE_METHOD.add(runAll);\n}\n\nexport function add(fn) {\n  startListening();\n  if (typeof fn !== 'function') throw new Error('Listener is no function');\n  LISTENERS.add(fn);\n  var addReturn = {\n    remove: function remove() {\n      return LISTENERS[\"delete\"](fn);\n    },\n    run: function run() {\n      LISTENERS[\"delete\"](fn);\n      return fn();\n    }\n  };\n  return addReturn;\n}\nexport function runAll() {\n  var promises = [];\n  LISTENERS.forEach(function (fn) {\n    promises.push(fn());\n    LISTENERS[\"delete\"](fn);\n  });\n  return Promise.all(promises);\n}\nexport function removeAll() {\n  LISTENERS.clear();\n}\nexport function getSize() {\n  return LISTENERS.size;\n}","import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE } from './util.js';\nimport { add as unloadAdd } from 'unload';\n\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this.hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n\n  this._aplQ = PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\n\n  this._aplQC = 0; // things to clean up\n\n  this._unl = []; // _unloads\n\n  this._lstns = []; // _listeners\n\n  this._dpL = function () {}; // onduplicate listener\n\n\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this.hasLeader = false;\n      }\n\n      if (msg.action === 'tell') {\n        _this.hasLeader = true;\n      }\n    }\n  };\n\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n\n  this._lstns.push(hasLeaderListener);\n};\n\nLeaderElection.prototype = {\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n    /**\n     * Already applying more then once,\n     * -> wait for the apply queue to be finished.\n     */\n\n\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n    /**\n     * Add a new apply-run\n     */\n\n\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var recieved = [];\n\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          recieved.push(msg);\n\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2.hasLeader = true;\n          }\n        }\n      };\n\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other intances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n\n\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      }) // send again in case another instance was just created\n      .then(function () {\n        return _sendMessage(_this2, 'apply');\n      }) // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n\n      return applyPromise;\n    };\n\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if (\n    /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n\n    return this._aLP;\n  },\n\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n\n  die: function die() {\n    var _this3 = this;\n\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n\n    this._lstns = [];\n\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n\n    this._unl = [];\n\n    if (this.isLeader) {\n      this.hasLeader = false;\n      this.isLeader = false;\n    }\n\n    this.isDead = true;\n    return _sendMessage(this, 'death');\n  }\n};\n/**\n * @param leaderElector {LeaderElector}\n */\n\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n\n  return new Promise(function (res) {\n    var resolved = false;\n\n    function finish() {\n      if (resolved) {\n        return;\n      }\n\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    } // try once now\n\n\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n\n    tryOnFallBack(); // try when other leader dies\n\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\n/**\n * sends and internal message over the broadcast-channel\n */\n\n\nfunction _sendMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\n\nexport function beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector.hasLeader = true;\n  var unloadFn = unloadAdd(function () {\n    return leaderElector.die();\n  });\n\n  leaderElector._unl.push(unloadFn);\n\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell');\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n\n\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n\n  leaderElector._lstns.push(isLeaderListener);\n\n  return _sendMessage(leaderElector, 'tell');\n}\n\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n\n  return options;\n}\n\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = new LeaderElection(channel, options);\n\n  channel._befC.push(function () {\n    return elector.die();\n  });\n\n  channel._leaderElector = elector;\n  return elector;\n}","import { BroadcastChannel } from \"broadcast-channel\"\nlet channel\n\nexport const createChannel = ({channelName = \"\"}) => (store) => {\n  channel = new BroadcastChannel(\"@lianulloa/vuex-module-maker/\" + channelName)\n  channel.onmessage = ({ type, payload }) => {\n    switch (type) {\n      case \"dispatch\":\n        store.dispatch(payload)\n        break\n      default:\n        break\n    }\n  }\n}\n\nexport const getChannel = () => channel\n\nexport default channel","/**\n * The action configuration object\n * @typedef {Object} ActionConfig\n * @property {Function} service - Service used to obtain data\n * @property {String}   attr - The attribute of the state which will contain the data (if any)\n * @property {String}   [mutation] - Mutation to used to set data when it is not the default for the attr\n * @property {boolean}  [spreadServiceArgs] - Whether action argument should be spreaded into the service\n * @property {boolean}  [append] - Whether data should be appended to existing data in a list format if requestBody.append === true\n * @property {boolean}  [appendAlways] - Whether data should be appended to existing data in a list format even though is not requested\n * @property {boolean}  [editing] - Whether it is an editing action. CANNOT be used along with append or appendAlways\n * @property {Function}  [editingRefreshService] - Service used to refresh an edited document. MUST be defined if requestBody.refresh\n * @property {boolean}  [hasMetadata] - Whether response will included a metadata field. If metadata is true, then mutation MUST NOT be defined\n * @property {String}   [cacheAPIRequestIn] - Name of an action, automatically created, to cache API resquest made through service\n * @property {boolean}  [cacheActionToDelete] - Name of an action to delete from cache after the request to API. If it is not in cache, it does nothing\n */\n\n/**\n * The VuexModuleMaker config\n * @typedef {Object} Config\n * @property {Object} state\n * @property {Object.<string,function|string>} getters\n * @property {Object.<string,function|string>} mutations\n * @property {Object.<string,Function| ActionConfig>} actions\n * @property {Object} options\n */\n\nimport { getFieldFrom, camelToUpSnake } from \"./utils/jsHelpers\"\nimport messages from './utils/messages'\nimport actionConfigs from \"./actionConfigs\"\nimport { getChannel } from \"./channel\"\n\nexport default class VuexModuleMaker {\n  /**\n   * @param {Config} config\n   */\n  constructor(\n    { state = {}, getters = {}, mutations = {}, actions = {} },\n    options = { namespaced: true, moduleName: '' }\n  ) {\n    this._state = typeof state === 'function' ? state() : state\n    this._getters = [\n      ...Object.keys(typeof state === 'function' ? state() : state),\n      getters,\n    ]\n    this._actions = actions\n    this.options = options\n\n    this._mutations = [\n      ...this._getDefaultMutations(this._state, actions),\n      mutations,\n    ]\n\n    this._cachedActions = {}\n\n    try {\n      this.vuexCache = require('vuex-cache')\n    } catch (e) {\n      this.vuexCache = {}\n    }\n  }\n\n  getModule() {\n    return {\n      state: this._state,\n      getters: this.buildGetters(),\n      mutations: this.buildMutations(),\n      actions: this.buildActions(),\n      ...this.options,\n    }\n  }\n\n  _getDefaultMutations(state, actions) {\n    const defaultMutations = new Set(Object.keys(state))\n    // Add mutations as needed in actions\n    const mutationsNeeded = new Set(\n      Object.values(actions)\n        .filter(action => typeof action === \"object\" && !action.mutation)\n        .map(action => action.attr)\n    )\n    for (const mutationFromAction of mutationsNeeded) {\n      defaultMutations.add(mutationFromAction)\n    }\n\n    return defaultMutations\n  }\n\n  /**\n   * Adds a getter. If getter names collide, the last added\n   * will be the one used\n   *\n   * Note for developer: for now that precedence behaviour\n   * is a result of overwritting a key's value on the getter\n   * object been built, but this can be improve by using a Set\n   * for the _getters property(Comming soon)\n   *\n   * @param {Object.<string,function|string>} getter\n   */\n  addGetter(getter) {\n    this._getters.push(getter)\n    return this\n  }\n\n  /**\n   * Adds a mutation. If mutation names collide, the last added\n   * will be the one used\n   *\n   * Note for developer: for now that precedence behaviour\n   * is a result of overwritting a key's value on the getter\n   * object been built, but this can be improve by using a Set\n   * for the _getters property(Comming soon)\n   * @param {Object.<string,function|string>} mutation\n   */\n  addMutation(mutation) {\n    this._mutations.push(mutation)\n    return this\n  }\n\n  addAction({ actionName, action }) {\n    if (typeof action === \"object\" && !action.mutation) {\n      const defaultMutations = this._mutations.filter(mutation => typeof mutation === \"string\")\n      if (!defaultMutations.some(dM => dM === action.attr)) {\n        // if there is no mutations for this action's attr, set one\n        this._mutations.push(action.attr)\n      }\n    }\n    this._actions[actionName] = action\n    return this\n  }\n\n  buildGetters() {\n    const getters = {}\n    let fieldChain\n    for (const getter of this._getters) {\n      if (typeof getter === \"string\") {\n        // if getter is string then it is a dotted path to value to be returned from module state\n        // Ex: state => state.user.name then getter === \"user.name\"\n        fieldChain = getter.split(\".\")\n        const binded = getFieldFrom.bind(null, fieldChain)\n        getters[fieldChain[fieldChain.length - 1]] = binded\n      } else if (typeof getter === \"object\") {\n        // if getter is object then each key (i.e. entry[0]) is the name of a getter\n        for (const entry of Object.entries(getter)) {\n          if (typeof entry[1] === \"string\") {\n            // if value (i.e. entry[1]) is string then it is a dotted path to value to be returned from module state\n            fieldChain = getter.split(\".\")\n            const binded = getFieldFrom.bind(null, fieldChain)\n            getters[entry[0]] = binded\n          } else if (typeof entry[1] === \"function\") {\n            // if value (i.e. entry[1]) is function then is a whole getter definition\n            getters[entry[0]] = entry[1]\n          }\n        }\n      }\n    }\n    return getters\n  }\n\n  buildMutations() {\n    const mutations = {}\n    for (const mutation of this._mutations) {\n      if (typeof mutation === \"string\") {\n        // if mutation is string then it is the field to be set. A vuex mutation is created\n        // using this string.\n        // Ex: if mutation === \"user\" then a vuex mutation is created, name SET_USER\n        // mutations[\"SET_\" + mutation.toUpperCase()] = (state, payload) => (state[mutation] = payload)\n        mutations[\"SET_\" + camelToUpSnake(mutation)] = (state, payload) =>\n          (state[mutation] = payload)\n      } else if (typeof mutation === \"object\") {\n        // if mutation is object then each key (i.e. entry[0]) is the name of a mutation\n        for (const entry of Object.entries(mutation)) {\n          if (typeof entry[1] === \"string\") {\n            // if value (i.e. entry[1]) is string then it is the state's field to be set\n            mutations[entry[0]] = (state, payload) => (state[entry[1]] = payload)\n          } else if (typeof entry[1] === \"function\") {\n            // if value (i.e. entry[1]) is function then it is a whole mutation definition\n            mutations[entry[0]] = entry[1]\n          }\n        }\n      }\n    }\n    return mutations\n  }\n\n  buildActions() {\n    const actions = {}\n    // Every key of actions's object is going to be used as the name of the action\n    for (const action in this._actions) {\n      if (typeof this._actions[action] === 'function') {\n        // if the value is a function then it is a whole action definition\n        actions[action] = this._actions[action]\n      } else if (typeof this._actions[action] === 'object') {\n        // if the value is a object then it contains: a reference to the api service\n        // that must be used, stored in field \"service\", a string with the name of the\n        // field of state where the response will be saved stored in \"attr\".\n        // As an optional field it could contain a \"mutation\" field, which should be the\n        // name of a vuex mutation available in this module\n        const actionConfig = this._actions[action]\n\n        if (\n          (actionConfig.cacheAPIRequestIn ||\n            actionConfig.cacheActionToDelete) &&\n          !this.vuexCache.cacheAction\n        ) {\n          delete actionConfig.cacheAPIRequestIn\n          delete actionConfig.cacheActionToDelete\n          console.warn(\n            `${messages.prefix} ${messages.warnings.vuexCache.peerDependency}\\nCheck '${action}' action`\n          )\n        }\n\n        if (actionConfig.cacheAPIRequestIn) {\n          actions[actionConfig.cacheAPIRequestIn] =\n            this._createFetchAction(actionConfig)\n          const clearAction = this._getClearActionName(actionConfig.cacheAPIRequestIn)\n          actions[clearAction] = this._createClearCacheAction(actionConfig.cacheAPIRequestIn)\n        }\n\n        actions[action] = this.buildAction(actionConfig)\n      }\n    }\n    return actions\n  }\n\n  buildAction(actionConfig) {\n    // TODO: allow to define cache timeout through dispatch\n    const action = ({ commit, state, cache }, requestBody) => {\n      let append = actionConfig.appendAlways || (actionConfig.append && requestBody?.append)\n      let refresh = requestBody?.refresh && actionConfig.editingRefreshService\n      if (requestBody) {\n        delete requestBody.append\n      }\n\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (cache && actionConfig.cacheActionToDelete) {\n            this._deleteCacheAction(cache, actionConfig.cacheActionToDelete)\n\n            const channel = getChannel()\n            if (channel) {\n              channel.postMessage({\n                type: \"dispatch\",\n                payload: `${this.options.moduleName}/${this._getClearActionName(actionConfig.cacheActionToDelete)}`\n              })\n            }\n          }\n\n          let data =\n            cache && actionConfig.cacheAPIRequestIn\n              ? await this._cacheAction(cache, actionConfig.cacheAPIRequestIn, requestBody)\n              : await this._sendRequest(requestBody, actionConfig)\n\n          if (actionConfig.hasMetadata) {\n            commit(\"SET_TOTAL_\" + camelToUpSnake(actionConfig.attr), data.metadata.total)\n          }\n\n          if (actionConfig.attr || actionConfig.mutation) {\n            commit(\n              actionConfig.mutation\n                ? actionConfig.mutation\n                : 'SET_' + camelToUpSnake(actionConfig.attr),\n              await this._prepareDataToCommit(data, { ...actionConfig, append, state, refresh })\n            )\n          }\n\n          resolve(data)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }\n\n    return actionConfig.cacheAPIRequestIn || actionConfig.cacheActionToDelete\n      ? this.vuexCache.cacheAction(action)\n      : action\n  }\n\n  async _prepareDataToCommit(data, config) {\n    let preparedData = data\n    if (config.hasMetadata) {\n      preparedData = data.data\n    }\n\n    if (config.append) {\n      return Array.prototype.concat(config.state[config.attr], preparedData)\n    } else if (config.editing) {\n      const documents = [...config.state[config.attr]] // destructure array to ensure reactivity\n      const updatedDocumentIndex = documents.findIndex(document => document.id === preparedData.id)\n      if (config.refresh) {\n        const response = await config.editingRefreshService(preparedData.id)\n        preparedData = response.data\n      }\n      documents[updatedDocumentIndex] = preparedData\n      return documents\n    }\n    return preparedData\n  }\n\n  async _sendRequest(requestBody, config) {\n    if (config.spreadServiceArgs) {\n      // if need to pass more than one parameter to service\n      return (await config.service(...requestBody)).data\n    } else if (config.editing) {\n      return (await config.service(requestBody.id, requestBody.body)).data\n    } else {\n      return (await config.service(requestBody)).data\n    }\n  }\n\n  _createFetchAction(actionConfig) {\n    return (context, requestBody) => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const data = await this._sendRequest(requestBody, actionConfig)\n          resolve(data)\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n  }\n\n  _createClearCacheAction(actionToDelete) {\n    return this.vuexCache.cacheAction(context => {\n      this._deleteCacheAction(context.cache, actionToDelete)\n    })\n  }\n\n  _cacheAction(cache, actionToCache, requestBody) {\n    const requestBodyString = requestBody ? JSON.stringify(requestBody) : \"\"\n    if (this._cachedActions[actionToCache]) {\n      this._cachedActions[actionToCache].add(requestBodyString)\n    } else {\n      this._cachedActions[actionToCache] = new Set([requestBodyString])\n    }\n    return cache.dispatch(actionToCache, requestBody)\n  }\n\n  _deleteCacheAction(cache, actionToDelete) {\n    if (this._cachedActions[actionToDelete]) {\n      for (const requestBodyString of this._cachedActions[actionToDelete]) {\n        const requestBody = requestBodyString !== \"\" ? JSON.parse(requestBodyString) : undefined\n        if (cache.has(actionToDelete, requestBody)) {\n          cache.delete(actionToDelete, requestBody)\n        }\n      }\n      this._cachedActions[actionToDelete] = new Set()\n    }\n  }\n\n  _getClearActionName(actionToClear) {\n    const [, action] = actionToClear.split(\"/\")\n    return `clear${action[0].toUpperCase() + action.slice(1)}`\n  }\n}\n\nexport { actionConfigs }\n"],"names":["root","factory","exports","module","require","e","define","amd","self","__WEBPACK_EXTERNAL_MODULE__113__","Error","code","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","getFieldFrom","fieldChain","length","slice","camelToUpSnake","string","replace","m","toUpperCase","peerDependency","common","list","hasMetadata","append","create","appendAlways","edit","editing","Promise","resolve","PROMISE_RESOLVED_VOID","sleep","time","resolveWith","res","setTimeout","randomToken","Math","random","toString","substring","lastMs","additional","microSeconds","ms","Date","getTime","isNode","process","channelName","state","messagesCallback","bc","BroadcastChannel","subFns","onmessage","msg","data","close","channelState","onMessage","fn","postMessage","messageJson","err","reject","canBeUsed","window","_pubkey","type","averageResponseTime","ObliviousSet","ttl","this","map","Map","_to","has","add","_this","set","now","obliviousSet","olderThen","iterator","next","delete","removeTooOldValues","clear","originalOptions","arguments","options","JSON","parse","stringify","webWorkerSupport","idb","fallbackInterval","onclose","localstorage","removeTimeout","methods","node","maxParallelWrites","useFastPath","OBJECT_STORE_ID","TRANSACTION_SETTINGS","durability","getIdb","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","commitIndexedDBTransaction","tx","commit","_readLoop","closed","readNewMessages","then","db","lastCursorId","transaction","objectStore","ret","keyRangeValue","IDBKeyRange","bound","Infinity","getAll","getAllRequest","rej","onerror","onsuccess","target","result","openCursorRequest","openCursor","ev","cursor","id","push","getMessagesHigherThan","newerMessages","useMessages","filter","msgObj","uuid","eMIs","messagesCallbackTime","_filterMessage","sort","msgObjA","msgObjB","forEach","dbName","openRequest","open","onupgradeneeded","createObjectStore","keyPath","autoIncrement","createDatabase","writeBlockPromise","readQueuePromises","readerUuid","writeObject","oncomplete","writeMessage","floor","msgObk","getOldMessages","tooOld","ids","all","deleteRequest","removeMessagesById","getLocalStorage","localStorage","storageKey","ls","setItem","removeItem","listener","newValue","token","addEventListener","addStorageEventListener","removeEventListener","writeObj","document","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","Set","name","Array","from","channel","METHODS","OPEN_BROADCAST_CHANNELS","lastId","method","chooseMethods","concat","Boolean","find","useMethod","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","maybePromise","s","_state","_prepareChannel","_post","broadcastChannel","sendPromise","_hasMessageListeners","_addListenerObject","listenerFn","listenerObject","minMessageTime","_startListening","_removeListenerObject","_stopListening","postInternal","listenObj","awaitPrepare","isClosed","WorkerGlobalScope","createChannel","store","payload","dispatch","getChannel","VuexModuleMaker","constructor","getters","mutations","actions","namespaced","moduleName","_getters","keys","_actions","_mutations","_getDefaultMutations","_cachedActions","vuexCache","getModule","buildGetters","buildMutations","buildActions","defaultMutations","mutationsNeeded","values","action","mutation","attr","mutationFromAction","addGetter","addMutation","addAction","actionName","some","dM","split","binded","bind","entry","entries","actionConfig","cacheAPIRequestIn","cacheActionToDelete","cacheAction","console","warn","messages","_createFetchAction","_getClearActionName","_createClearCacheAction","buildAction","requestBody","cache","refresh","editingRefreshService","_deleteCacheAction","_cacheAction","_sendRequest","metadata","total","_prepareDataToCommit","config","preparedData","documents","updatedDocumentIndex","findIndex","response","spreadServiceArgs","service","body","context","error","actionToDelete","actionToCache","requestBodyString","actionToClear"],"sourceRoot":""}