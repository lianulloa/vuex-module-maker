{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///external {\"commonjs\":\"vuex-cache\",\"commonjs2\":\"vuex-cache\",\"amd\":\"vuex-cache\",\"root\":\"vuex-cache\"}","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/utils/jsHelpers.js","webpack:///./src/actionConfigs.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/util.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/native.js","webpack:///./node_modules/oblivious-set/dist/es/index.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/options.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js","webpack:///./src/channel.js","webpack:///./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js","webpack:///./src/VuexModuleMaker.js"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__614__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","getFieldFrom","fieldChain","length","slice","camelToUpSnake","string","replace","m","toUpperCase","common","list","hasMetadata","append","create","appendAlways","edit","editing","sleep","time","Promise","res","setTimeout","randomToken","Math","random","toString","substring","lastMs","additional","microSeconds","ms","Date","getTime","isNode","process","channelName","state","messagesCallback","bc","BroadcastChannel","subFns","onmessage","msg","data","close","channelState","onMessage","fn","postMessage","messageJson","resolve","err","reject","canBeUsed","window","_pubkey","Error","type","averageResponseTime","ObliviousSet","ttl","this","set","Set","timeMap","Map","has","add","_this","now","obliviousSet","olderThen","iterator","next","delete","removeTooOldValues","clear","originalOptions","arguments","options","JSON","parse","stringify","webWorkerSupport","idb","fallbackInterval","onclose","localstorage","removeTimeout","methods","node","useFastPath","OBJECT_STORE_ID","getIdb","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","_readLoop","closed","readNewMessages","then","db","lastCursorId","objectStore","transaction","ret","keyRangeValue","IDBKeyRange","bound","Infinity","openCursor","e","onsuccess","ev","cursor","target","result","id","push","newerMessages","filter","msgObj","map","uuid","eMIs","messagesCallbackTime","_filterMessage","sort","msgObjA","msgObjB","forEach","dbName","openRequest","open","onupgradeneeded","createObjectStore","keyPath","autoIncrement","rej","onerror","createDatabase","writeBlockPromise","readQueuePromises","readerUuid","writeObject","oncomplete","writeMessage","floor","msgObk","getOldMessages","tooOld","all","request","removeMessageById","getLocalStorage","localStorage","storageKey","ls","setItem","removeItem","listener","newValue","token","addEventListener","addStorageEventListener","removeEventListener","writeObj","document","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","name","Array","from","channel","METHODS","method","chooseMethods","concat","Boolean","find","useMethod","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","maybePromise","s","_state","_prepareChannel","_post","broadcastChannel","sendPromise","_hasMessageListeners","_addListenerObject","listenerFn","_startListening","_removeListenerObject","_stopListening","postInternal","listenObj","awaitPrepare","createChannel","store","payload","dispatch","getChannel","VuexModuleMaker","constructor","getters","mutations","actions","namespaced","moduleName","_getters","keys","_actions","_mutations","_getDefaultMutations","_cachedActions","getModule","buildGetters","buildMutations","buildActions","defaultMutations","mutationsNeeded","values","action","mutation","attr","mutationFromAction","addGetter","getter","addMutation","addAction","actionName","some","dM","split","binded","bind","entry","entries","actionConfig","cacheAPIRequestIn","_createFetchAction","_getClearActionName","_createClearCacheAction","buildAction","requestBody","commit","cache","refresh","editingRefreshService","cacheActionToDelete","_deleteCacheAction","_cacheAction","_sendRequest","metadata","total","_prepareDataToCommit","cacheAction","config","preparedData","documents","updatedDocumentIndex","findIndex","response","spreadServiceArgs","service","body","context","error","actionToDelete","actionToCache","requestBodyString","actionToClear"],"mappings":"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","file":"vuex-module-maker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vuex-cache\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vuex-cache\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vuexModuleMaker\"] = factory(require(\"vuex-cache\"));\n\telse\n\t\troot[\"vuexModuleMaker\"] = factory(root[\"vuex-cache\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__614__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__614__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export function getFieldFrom(fieldChain, obj) {\n  if (!fieldChain.length) return obj\n\n  if (Object.prototype.hasOwnProperty.call(obj, fieldChain[0])) {\n    return getFieldFrom(fieldChain.slice(1), obj[fieldChain[0]])\n  } else {\n    return null\n  }\n}\n\nexport function camelToUpSnake(string) {\n  return string\n    .replace(/([A-Z])/g, function (m) {\n      return \"_\" + m\n    })\n    .toUpperCase()\n}\n","export default {\n  common: {\n    list: {\n      hasMetadata: true,\n      append: true\n    },\n    create: {\n      appendAlways: true\n    },\n    edit: {\n      editing: true\n    }\n  }\n}\n","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function sleep(time) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */\n\nexport function randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nexport function microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n/**\n * copied from the 'detect-node' npm module\n * We cannot use the module directly because it causes problems with rollup\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\n\nexport var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';","import { microSeconds as micro, isNode } from '../util';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return Promise.resolve();\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (isNode && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.set = new Set();\n        this.timeMap = new Map();\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.set.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.timeMap.set(value, now());\n        this.set.add(value);\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        setTimeout(function () {\n            removeTooOldValues(_this);\n        }, 0);\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.set.clear();\n        this.timeMap.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.set[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var value = iterator.next().value;\n        if (!value) {\n            return; // no more elements\n        }\n        var time = obliviousSet.timeMap.get(value);\n        if (time < olderThen) {\n            obliviousSet.timeMap.delete(value);\n            obliviousSet.set.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map","export function fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.\n\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods\n\n  if (originalOptions.methods) options.methods = originalOptions.methods; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nexport function getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res) {\n    openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro, isNode } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = randomToken();\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n\n  return defaultTime;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import { microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return 5;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import NativeMethod from './methods/native.js';\nimport IndexeDbMethod from './methods/indexed-db.js';\nimport LocalstorageMethod from './methods/localstorage.js';\nimport SimulateMethod from './methods/simulate.js'; // the line below will be removed from es5/browser builds\n\n\nimport { isNode } from './util'; // order is important\n\nvar METHODS = [NativeMethod, // fastest\nIndexeDbMethod, LocalstorageMethod];\nexport function chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds\n\n\n\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n\n\n  if (!options.webWorkerSupport && !isNode) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error(\"No useable method found in \" + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}","import { BroadcastChannel } from \"broadcast-channel\"\nlet channel\n\nexport const createChannel = ({channelName = \"\"}) => (store) => {\n  channel = new BroadcastChannel(\"@lianulloa/vuex-module-maker/\" + channelName)\n  channel.onmessage = ({ type, payload }) => {\n    switch (type) {\n      case \"dispatch\":\n        store.dispatch(payload)\n        break\n      default:\n        break\n    }\n  }\n}\n\nexport const getChannel = () => channel\n\nexport default channel","import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n}\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","/**\n * The action configuration object\n * @typedef {Object} ActionConfig\n * @property {Function} service - Service used to obtain data\n * @property {String}   attr - The attribute of the state which will contain the data (if any)\n * @property {String}   [mutation] - Mutation to used to set data when it is not the default for the attr\n * @property {boolean}  [spreadServiceArgs] - Whether action argument should be spreaded into the service\n * @property {boolean}  [append] - Whether data should be appended to existing data in a list format if requestBody.append === true\n * @property {boolean}  [appendAlways] - Whether data should be appended to existing data in a list format even though is not requested\n * @property {boolean}  [editing] - Whether it is an editing action. CANNOT be used along with append or appendAlways\n * @property {Function}  [editingRefreshService] - Service used to refresh an edited document. MUST be defined if requestBody.refresh\n * @property {boolean}  [hasMetadata] - Whether response will included a metadata field. If metadata is true, then mutation MUST NOT be defined\n * @property {String}   [cacheAPIRequestIn] - Name of an action, automatically created, to cache API resquest made through service\n * @property {boolean}  [cacheActionToDelete] - Name of an action to delete from cache after the request to API. If it is not in cache, it does nothing\n */\n\n/**\n * The VuexModuleMaker config\n * @typedef {Object} Config\n * @property {Object} state\n * @property {Object.<string,function|string>} getters\n * @property {Object.<string,function|string>} mutations\n * @property {Object.<string,Function| ActionConfig>} actions\n * @property {Object} options\n */\n\nimport { getFieldFrom, camelToUpSnake } from \"./utils/jsHelpers\"\nimport { cacheAction } from \"vuex-cache\"\nimport actionConfigs from \"./actionConfigs\"\nimport { getChannel } from \"./channel\"\n\nexport default class VuexModuleMaker {\n  /**\n   * @param {Config} config\n   */\n  constructor({ state = {}, getters = {}, mutations = {}, actions = {} }, options = { namespaced: true, moduleName: \"\" }) {\n    this._state = state\n    this._getters = [...Object.keys(state), getters]\n    this._actions = actions\n    this.options = options\n\n    this._mutations = [...this._getDefaultMutations(state, actions), mutations]\n\n    this._cachedActions = {}\n  }\n\n  getModule() {\n    return {\n      state: this._state,\n      getters: this.buildGetters(),\n      mutations: this.buildMutations(),\n      actions: this.buildActions(),\n      ...this.options\n    }\n  }\n\n  _getDefaultMutations(state, actions) {\n    const defaultMutations = new Set(Object.keys(state))\n    //Add mutations as needed in actions\n    let mutationsNeeded = new Set(\n      Object.values(actions)\n        .filter(action => typeof action === \"object\" && !action.mutation)\n        .map(action => action.attr)\n    )\n    for (const mutationFromAction of mutationsNeeded) {\n      defaultMutations.add(mutationFromAction)\n    }\n\n    return defaultMutations\n  }\n\n  /**\n   * Adds a getter. If getter names collide, the last added\n   * will be the one used\n   *\n   * Note for developer: for now that precedence behaviour\n   * is a result of overwritting a key's value on the getter\n   * object been built, but this can be improve by using a Set\n   * for the _getters property(Comming soon)\n   *\n   * @param {Object.<string,function|string>} getter\n   */\n  addGetter(getter) {\n    this._getters.push(getter)\n    return this\n  }\n\n  /**\n   * Adds a mutation. If mutation names collide, the last added\n   * will be the one used\n   *\n   * Note for developer: for now that precedence behaviour\n   * is a result of overwritting a key's value on the getter\n   * object been built, but this can be improve by using a Set\n   * for the _getters property(Comming soon)\n   * @param {Object.<string,function|string>} mutation\n   */\n  addMutation(mutation) {\n    this._mutations.push(mutation)\n    return this\n  }\n\n  addAction({ actionName, action }) {\n    if (typeof action === \"object\" && !action.mutation) {\n      const defaultMutations = this._mutations.filter(mutation => typeof mutation === \"string\")\n      if (!defaultMutations.some(dM => dM === action.attr)) {\n        // if there is no mutations for this action's attr, set one\n        this._mutations.push(action.attr)\n      }\n    }\n    this._actions[actionName] = action\n    return this\n  }\n\n  buildGetters() {\n    const getters = {}\n    let fieldChain\n    for (const getter of this._getters) {\n      if (typeof getter === \"string\") {\n        // if getter is string then it is a dotted path to value to be returned from module state\n        // Ex: state => state.user.name then getter === \"user.name\"\n        fieldChain = getter.split(\".\")\n        const binded = getFieldFrom.bind(null, fieldChain)\n        getters[fieldChain[fieldChain.length - 1]] = binded\n      } else if (typeof getter === \"object\") {\n        // if getter is object then each key (i.e. entry[0]) is the name of a getter\n        for (const entry of Object.entries(getter)) {\n          if (typeof entry[1] === \"string\") {\n            // if value (i.e. entry[1]) is string then it is a dotted path to value to be returned from module state\n            fieldChain = getter.split(\".\")\n            const binded = getFieldFrom.bind(null, fieldChain)\n            getters[entry[0]] = binded\n          } else if (typeof entry[1] === \"function\") {\n            // if value (i.e. entry[1]) is function then is a whole getter definition\n            getters[entry[0]] = entry[1]\n          }\n        }\n      }\n    }\n    return getters\n  }\n  buildMutations() {\n    const mutations = {}\n    for (const mutation of this._mutations) {\n      if (typeof mutation === \"string\") {\n        // if mutation is string then it is the field to be set. A vuex mutation is created\n        // using this string.\n        // Ex: if mutation === \"user\" then a vuex mutation is created, name SET_USER\n        // mutations[\"SET_\" + mutation.toUpperCase()] = (state, payload) => (state[mutation] = payload)\n        mutations[\"SET_\" + camelToUpSnake(mutation)] = (state, payload) =>\n          (state[mutation] = payload)\n      } else if (typeof mutation === \"object\") {\n        // if mutation is object then each key (i.e. entry[0]) is the name of a mutation\n        for (const entry of Object.entries(mutation)) {\n          if (typeof entry[1] === \"string\") {\n            // if value (i.e. entry[1]) is string then it is the state's field to be set\n            mutations[entry[0]] = (state, payload) => (state[entry[1]] = payload)\n          } else if (typeof entry[1] === \"function\") {\n            // if value (i.e. entry[1]) is function then it is a whole mutation definition\n            mutations[entry[0]] = entry[1]\n          }\n        }\n      }\n    }\n    return mutations\n  }\n  buildActions() {\n    const actions = {}\n    // Every key of actions's object is going to be used as the name of the action\n    for (const action in this._actions) {\n      if (typeof this._actions[action] === \"function\") {\n        // if the value is a function then it is a whole action definition\n        actions[action] = this._actions[action]\n      } else if (typeof this._actions[action] === \"object\") {\n        // if the value is a object then it contains: a reference to the api service\n        // that must be used, stored in field \"service\", a string with the name of the\n        // field of state where the response will be saved stored in \"attr\".\n        // As an optional field it could contain a \"mutation\" field, which should be the\n        // name of a vuex mutation available in this module\n        const actionConfig = this._actions[action]\n        let clearAction\n        if (actionConfig.cacheAPIRequestIn) {\n          actions[actionConfig.cacheAPIRequestIn] = this._createFetchAction(actionConfig)\n          // const [, action] = actionConfig.cacheAPIRequestIn.split(\"/\")\n          clearAction = this._getClearActionName(actionConfig.cacheAPIRequestIn)\n          actions[clearAction] = this._createClearCacheAction(actionConfig.cacheAPIRequestIn)\n        }\n\n        actions[action] = this.buildAction(actionConfig)\n      }\n    }\n    return actions\n  }\n  buildAction(actionConfig) {\n    // TODO: allow to define cache timeout through dispatch\n    const action = ({ commit, state, cache }, requestBody) => {\n      let append = actionConfig.appendAlways || (actionConfig.append && requestBody?.append)\n      let refresh = requestBody?.refresh && actionConfig.editingRefreshService\n      if (requestBody) {\n        delete requestBody[\"append\"]\n      }\n\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (cache && actionConfig.cacheActionToDelete) {\n            this._deleteCacheAction(cache, actionConfig.cacheActionToDelete)\n\n            const channel = getChannel()\n            channel.postMessage({\n              type: \"dispatch\",\n              payload: `${this.options.moduleName}/${this._getClearActionName(actionConfig.cacheActionToDelete)}`\n            })\n          }\n\n          let data =\n            cache && actionConfig.cacheAPIRequestIn\n              ? await this._cacheAction(cache, actionConfig.cacheAPIRequestIn, requestBody)\n              : await this._sendRequest(requestBody, actionConfig)\n\n          if (actionConfig.hasMetadata) {\n            commit(\"SET_TOTAL_\" + camelToUpSnake(actionConfig.attr), data.metadata.total)\n          }\n\n          if (actionConfig.attr || actionConfig.mutation) {\n            commit(\n              actionConfig.mutation\n                ? actionConfig.mutation\n                : \"SET_\" + camelToUpSnake(actionConfig.attr),\n              await this._prepareDataToCommit(data, { ...actionConfig, append, state, refresh })\n            )\n          }\n\n          resolve(data)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }\n\n    return actionConfig.cacheAPIRequestIn || actionConfig.cacheActionToDelete\n      ? cacheAction(action)\n      : action\n  }\n\n  async _prepareDataToCommit(data, config) {\n    let preparedData = data\n    if (config.hasMetadata) {\n      preparedData = data.data\n    }\n\n    if (config.append) {\n      return Array.prototype.concat(config.state[config.attr], preparedData)\n    } else if (config.editing) {\n      const documents = [...config.state[config.attr]] //destructure array to ensure reactivity\n      const updatedDocumentIndex = documents.findIndex(document => document.id === preparedData.id)\n      if (config.refresh) {\n        const response = await config.editingRefreshService(preparedData.id)\n        preparedData = response.data\n      }\n      documents[updatedDocumentIndex] = preparedData\n      return documents\n    }\n    return preparedData\n  }\n\n  async _sendRequest(requestBody, config) {\n    if (config.spreadServiceArgs) {\n      // if need to pass more than one parameter to service\n      return (await config.service(...requestBody)).data\n    } else if (config.editing) {\n      return (await config.service(requestBody.id, requestBody.body)).data\n    } else {\n      return (await config.service(requestBody)).data\n    }\n  }\n\n  _createFetchAction(actionConfig) {\n    return (context, requestBody) => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const data = await this._sendRequest(requestBody, actionConfig)\n          resolve(data)\n        } catch (error) {\n          reject(error)\n        }\n      })\n    }\n  }\n\n  _createClearCacheAction(actionToDelete) {\n    return cacheAction(context => {\n      this._deleteCacheAction(context.cache, actionToDelete)\n    })\n  }\n\n  _cacheAction(cache, actionToCache, requestBody) {\n    const requestBodyString = requestBody ? JSON.stringify(requestBody) : \"\"\n    if (this._cachedActions[actionToCache]) {\n      this._cachedActions[actionToCache].add(requestBodyString)\n    } else {\n      this._cachedActions[actionToCache] = new Set([requestBodyString])\n    }\n    return cache.dispatch(actionToCache, requestBody)\n  }\n\n  _deleteCacheAction(cache, actionToDelete) {\n    if (this._cachedActions[actionToDelete]) {\n      for (const requestBodyString of this._cachedActions[actionToDelete]) {\n        const requestBody = requestBodyString !== \"\" ? JSON.parse(requestBodyString) : undefined\n        if (cache.has(actionToDelete, requestBody)) {\n          cache.delete(actionToDelete, requestBody)\n        }\n      }\n      this._cachedActions[actionToDelete] = new Set()\n    }\n  }\n\n  _getClearActionName(actionToClear) {\n    const [, action] = actionToClear.split(\"/\")\n    return `clear${action[0].toUpperCase() + action.slice(1)}`\n  }\n}\n\nexport { actionConfigs }\n"],"sourceRoot":""}